<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Bus Rush 3D</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        .ui-layer { position: absolute; z-index: 10; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: center; align-items: center; }
        .pointer-events-auto { pointer-events: auto; }
        .hud { position: absolute; top: 20px; left: 20px; right: 20px; display: flex; justify-content: space-between; pointer-events: none; }
        .neon-text {
            text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 20px #ff00de, 0 0 30px #ff00de, 0 0 40px #ff00de;
        }
        .neon-box {
            box-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 20px #0ff, 0 0 30px #0ff;
            border: 2px solid #0ff;
            background: rgba(0, 0, 0, 0.8);
        }
        /* Scanline effect */
        .scanlines {
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.2) 50%,
                rgba(0,0,0,0.2)
            );
            background-size: 100% 4px;
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            z-index: 5;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <!-- Game Canvas -->
    <div id="canvas-container"></div>
    <div class="scanlines"></div>

    <!-- HUD -->
    <div id="hud" class="hud hidden">
        <div class="text-white text-2xl font-bold drop-shadow-md">SCORE: <span id="score">0</span></div>
        <div class="text-white text-2xl font-bold drop-shadow-md">SPEED: <span id="speed-display">0</span> km/h</div>
    </div>

    <!-- Start Screen -->
    <div id="start-screen" class="ui-layer bg-black/80 backdrop-blur-sm pointer-events-auto">
        <h1 class="text-6xl md:text-8xl font-black text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-purple-600 mb-4 neon-text italic transform -skew-x-12">NEON BUS</h1>
        <p class="text-gray-300 mb-8 text-xl">Dodge traffic. Collect energy. Don't crash.</p>
        <div class="flex gap-4">
            <button id="start-btn" class="neon-box px-8 py-4 text-cyan-300 font-bold text-xl uppercase hover:bg-cyan-900/50 transition-all transform hover:scale-105 rounded">
                Start Engine
            </button>
        </div>
        <p class="mt-8 text-gray-500 text-sm">Controls: Arrow Keys / A & D or Touch Sides</p>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen" class="ui-layer bg-red-900/80 backdrop-blur-sm hidden pointer-events-auto">
        <h2 class="text-6xl font-black text-white mb-2 neon-text" style="text-shadow: 0 0 20px red;">CRASHED!</h2>
        <p class="text-white text-2xl mb-6">Final Score: <span id="final-score">0</span></p>
        <button id="restart-btn" class="neon-box px-8 py-4 text-red-300 font-bold text-xl uppercase hover:bg-red-900/50 transition-all transform hover:scale-105 rounded border-red-500 shadow-red-500">
            Try Again
        </button>
    </div>

    <script>
        // --- Game Configuration & State ---
        const CONFIG = {
            laneWidth: 4,
            busSpeed: 0.2,
            maxSpeed: 1.5,
            acceleration: 0.0001,
            obstacleSpawnRate: 40, // frames
            colors: {
                bus: 0xffcc00,
                busDetail: 0x222222,
                road: 0x111111,
                grid: 0xff00de,
                sky: 0x050510,
                obstacle: 0xff3333,
                collectible: 0x00ffff
            }
        };

        let state = {
            isPlaying: false,
            score: 0,
            speed: 0,
            distance: 0,
            frame: 0
        };

        // --- Three.js Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(CONFIG.colors.sky);
        scene.fog = new THREE.FogExp2(CONFIG.colors.sky, 0.015);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 10);
        camera.lookAt(0, 0, -20);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 1024;
        dirLight.shadow.mapSize.height = 1024;
        scene.add(dirLight);

        // --- Audio System (Web Audio API) ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioCtx;

        function initAudio() {
            if (!audioCtx) audioCtx = new AudioContext();
            if (audioCtx.state === 'suspended') audioCtx.resume();
        }

        function playSound(type) {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            const now = audioCtx.currentTime;

            if (type === 'start') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(110, now);
                osc.frequency.exponentialRampToValueAtTime(880, now + 0.5);
                gainNode.gain.setValueAtTime(0.3, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                osc.start(now);
                osc.stop(now + 0.5);
            } else if (type === 'collect') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(880, now);
                osc.frequency.exponentialRampToValueAtTime(1760, now + 0.1);
                gainNode.gain.setValueAtTime(0.2, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === 'crash') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(100, now);
                osc.frequency.exponentialRampToValueAtTime(10, now + 0.5);
                gainNode.gain.setValueAtTime(0.5, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                osc.start(now);
                osc.stop(now + 0.5);
            }
        }

        // --- Game Objects ---

        // 1. The Bus (Player)
        const busGroup = new THREE.Group();
        
        // Bus Body
        const bodyGeo = new THREE.BoxGeometry(2.2, 1.5, 5);
        const bodyMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.bus, roughness: 0.2 });
        const busBody = new THREE.Mesh(bodyGeo, bodyMat);
        busBody.position.y = 1.25;
        busBody.castShadow = true;
        busGroup.add(busBody);

        // Bus Windows
        const windowGeo = new THREE.BoxGeometry(2.3, 0.6, 3);
        const windowMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.0 });
        const busWindows = new THREE.Mesh(windowGeo, windowMat);
        busWindows.position.set(0, 1.6, -0.2);
        busGroup.add(busWindows);

        // Headlights
        const lightGeo = new THREE.BoxGeometry(0.4, 0.2, 0.1);
        const lightMat = new THREE.MeshBasicMaterial({ color: 0xffffaa });
        const leftLight = new THREE.Mesh(lightGeo, lightMat);
        leftLight.position.set(-0.7, 1, 2.51);
        const rightLight = new THREE.Mesh(lightGeo, lightMat);
        rightLight.position.set(0.7, 1, 2.51);
        busGroup.add(leftLight);
        busGroup.add(rightLight);

        // Headlight Beams
        const spotLightL = new THREE.SpotLight(0xffffee, 2, 40, 0.5, 0.5, 1);
        spotLightL.position.set(-0.7, 1, 2.5);
        spotLightL.target.position.set(-0.7, 0, 10);
        busGroup.add(spotLightL);
        busGroup.add(spotLightL.target);

        const spotLightR = new THREE.SpotLight(0xffffee, 2, 40, 0.5, 0.5, 1);
        spotLightR.position.set(0.7, 1, 2.5);
        spotLightR.target.position.set(0.7, 0, 10);
        busGroup.add(spotLightR);
        busGroup.add(spotLightR.target);

        // Wheels
        const wheelGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.3, 16);
        const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
        const positions = [
            [-1.1, 0.4, 1.5], [1.1, 0.4, 1.5],
            [-1.1, 0.4, -1.5], [1.1, 0.4, -1.5]
        ];
        positions.forEach(pos => {
            const wheel = new THREE.Mesh(wheelGeo, wheelMat);
            wheel.rotation.z = Math.PI / 2;
            wheel.position.set(...pos);
            busGroup.add(wheel);
        });

        scene.add(busGroup);

        // 2. The Environment
        // Moving Grid Floor
        const gridHelper = new THREE.GridHelper(200, 100, CONFIG.colors.grid, 0x222222);
        gridHelper.position.y = 0;
        scene.add(gridHelper);

        const planeGeo = new THREE.PlaneGeometry(200, 200);
        const planeMat = new THREE.MeshBasicMaterial({ color: CONFIG.colors.road });
        const floor = new THREE.Mesh(planeGeo, planeMat);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -0.1;
        scene.add(floor);

        // 3. Object Management
        let obstacles = [];
        let collectibles = [];
        const obstacleGeo = new THREE.BoxGeometry(2.5, 2, 4.5);
        const obstacleMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.obstacle });
        const collectibleGeo = new THREE.SphereGeometry(0.5, 16, 16);
        const collectibleMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.collectible, emissive: 0x00aaaa, emissiveIntensity: 0.5 });

        function spawnObstacle() {
            const lane = Math.floor(Math.random() * 3) - 1; // -1, 0, 1
            const mesh = new THREE.Mesh(obstacleGeo, obstacleMat);
            mesh.position.set(lane * CONFIG.laneWidth, 1, -100);
            mesh.castShadow = true;
            scene.add(mesh);
            obstacles.push(mesh);
        }

        function spawnCollectible() {
            const lane = Math.floor(Math.random() * 3) - 1;
            const mesh = new THREE.Mesh(collectibleGeo, collectibleMat);
            mesh.position.set(lane * CONFIG.laneWidth, 1.5, -100);
            scene.add(mesh);
            collectibles.push(mesh);
        }

        // --- Logic & Control ---
        let targetLane = 0; // -1, 0, 1
        let busX = 0;

        function handleInput(direction) {
            if (!state.isPlaying) return;
            if (direction === 'left' && targetLane > -1) targetLane--;
            if (direction === 'right' && targetLane < 1) targetLane++;
        }

        window.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') handleInput('left');
            if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') handleInput('right');
        });

        // Touch controls
        window.addEventListener('touchstart', (e) => {
            if (!state.isPlaying) return;
            const touchX = e.touches[0].clientX;
            if (touchX < window.innerWidth / 2) handleInput('left');
            else handleInput('right');
        });

        function checkCollisions() {
            // Bus bounding box approximation
            const busBox = new THREE.Box3().setFromObject(busBody);
            
            // Check Obstacles
            for (let i = 0; i < obstacles.length; i++) {
                const obsBox = new THREE.Box3().setFromObject(obstacles[i]);
                if (busBox.intersectsBox(obsBox)) {
                    gameOver();
                    return;
                }
            }

            // Check Collectibles
            for (let i = collectibles.length - 1; i >= 0; i--) {
                const colBox = new THREE.Box3().setFromObject(collectibles[i]);
                if (busBox.intersectsBox(colBox)) {
                    scene.remove(collectibles[i]);
                    collectibles.splice(i, 1);
                    state.score += 50;
                    playSound('collect');
                    updateHUD();
                }
            }
        }

        function updateHUD() {
            document.getElementById('score').innerText = Math.floor(state.score);
            document.getElementById('speed-display').innerText = Math.floor(state.speed * 200);
        }

        function gameOver() {
            state.isPlaying = false;
            playSound('crash');
            document.getElementById('hud').classList.add('hidden');
            document.getElementById('game-over-screen').classList.remove('hidden');
            document.getElementById('final-score').innerText = Math.floor(state.score);
        }

        function resetGame() {
            state.score = 0;
            state.speed = CONFIG.busSpeed;
            state.distance = 0;
            state.frame = 0;
            targetLane = 0;
            busGroup.position.x = 0;
            busGroup.rotation.z = 0;

            // Clear objects
            obstacles.forEach(o => scene.remove(o));
            collectibles.forEach(c => scene.remove(c));
            obstacles = [];
            collectibles = [];

            updateHUD();
        }

        function startGame() {
            initAudio();
            playSound('start');
            resetGame();
            state.isPlaying = true;
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('game-over-screen').classList.add('hidden');
            document.getElementById('hud').classList.remove('hidden');
        }

        // --- Main Loop ---
        function animate() {
            requestAnimationFrame(animate);

            if (state.isPlaying) {
                // Increase speed over time
                if (state.speed < CONFIG.maxSpeed) {
                    state.speed += CONFIG.acceleration;
                }

                // Move Bus (Lerp for smooth lane change)
                const targetX = targetLane * CONFIG.laneWidth;
                busGroup.position.x += (targetX - busGroup.position.x) * 0.1;
                
                // Tilt bus when turning
                const tilt = (busGroup.position.x - targetX) * 0.1;
                busGroup.rotation.z = tilt;
                busGroup.rotation.y = -tilt * 0.5;

                // Move Environment (Illusion of speed)
                const moveSpeed = state.speed;
                state.distance += moveSpeed;
                state.score += moveSpeed * 0.1;

                // Grid scrolling effect
                gridHelper.position.z = (state.distance % 10);

                // Spawn Objects
                state.frame++;
                if (state.frame % Math.floor(CONFIG.obstacleSpawnRate / state.speed) === 0) {
                    spawnObstacle();
                    // Chance to spawn collectible
                    if (Math.random() > 0.5) spawnCollectible();
                }

                // Move Obstacles
                for (let i = obstacles.length - 1; i >= 0; i--) {
                    obstacles[i].position.z += moveSpeed;
                    if (obstacles[i].position.z > 10) {
                        scene.remove(obstacles[i]);
                        obstacles.splice(i, 1);
                    }
                }

                // Move Collectibles
                for (let i = collectibles.length - 1; i >= 0; i--) {
                    collectibles[i].position.z += moveSpeed;
                    collectibles[i].rotation.y += 0.05; // Spin
                    if (collectibles[i].position.z > 10) {
                        scene.remove(collectibles[i]);
                        collectibles.splice(i, 1);
                    }
                }

                checkCollisions();
                updateHUD();
            } else {
                // Idle animation
                busGroup.rotation.y = Math.sin(Date.now() * 0.001) * 0.1;
                gridHelper.position.z = (Date.now() * 0.005) % 10;
            }

            renderer.render(scene, camera);
        }

        // --- Event Listeners ---
        document.getElementById('start-btn').addEventListener('click', startGame);
        document.getElementById('restart-btn').addEventListener('click', startGame);

        // Window Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start Loop
        animate();

    </script>
</body>
</html>
